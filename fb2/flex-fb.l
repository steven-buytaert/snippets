%{

// Copyright (c) 2023 Steven Buytaert

#include <fb2-common.h>

#include <tokens.h>                 // Generated by bison; include after <fb2-common.h>.

static int32_t Row = 1;             // Row
static int32_t Col = 0;             // Column
static const char * line;           // Start of the current line.

static void adv(const char * txt, int32_t sz) {             // Advance the cursor based on the matched text.
   
  Col += sz;

  if ('\n' == txt[0]) {
    Row++;
    Col = 0;
    line = & txt[1];                                        // Start of the next line.
  }

}

static uint32_t roundup(uint32_t value, uint32_t pot) {     // Round up to a power of two.
  return (value + (pot - 1)) & ~(pot - 1);
}

static token_t token(ctx_t ctx, const char * text, int32_t size, int32_t type) {

  token_t  token;
  uint32_t sz = text ? (uint32_t) size : 0;                 // If text not NULL; note that Token already has space for the \0.

  assert(type != CHAR || (size == 1 && text[0] != ' '));    // For CHAR types, size should be just 1 and never a space.

  sz = roundup(sizeof(Token_t) + sz, alignof(Token_t));     // Aligned worst case size requirements.

  token = ctx->Tokens.obj(& ctx->Tokens, sz, alignof(Token_t));

  if (text) {
    memcpy(token->text, text, (uint32_t) size);
    token->size = size;
  }

  token->row = Row;
  token->col = Col;
  token->line = line;
  token->type = type;

  return token;

}

static int input(yyscan_t scanner);                         // Provided by flex.

static token_t str2token(ctx_t ctx, const char * start) {

  char       buffer[1024 * 16];
  char       c;                                             // The current input character.
  uint32_t   i = 0;                                         // The current buffer location.
  const char quote = start[0];
  uint32_t   sz = 0;                                        // To keep track of the linesize for advance.

  printf("Searching for next %c", quote);
  
  while (1) {                                               // Parse until we find a single "
    c = input(ctx->scanner);
    buffer[i] = c;
    sz++;

    if (-1 == c) {
      printf("Unexpected EOF\n");
      break;
    }
    else if (quote == c) {
      if (i && buffer[i] != '\\') {                         // It was not an escaped quote or double quote.
        break;                                              // End of cstring; buffer will be properly ended below.
      }
    }
    else if ('\n' == c) {
      adv(& start[i], (int32_t) sz);
      sz = 0;
    }          

    assert(i < sizeof(buffer));                             // Increase buffer if triggered.
    
    i++;

  }

  buffer[i] = '\0';                                         // Properly end the buffer

  printf("%s%c\n", buffer, quote);

  return token(ctx, buffer, (int32_t) i, CONST);

}

%}

%option reentrant extra-type="struct Ctx_t *"

FLOAT      [-+]?[0-9]*([0-9]\.|\.[0-9])[0-9]*([Ee]?[-+]?[0-9]+)
FALSE      [Ff][Aa][Ll][Ss][Ee]
TRUE       [Tt][Rr][Uu][Ee]
IDENTIFIER [a-zA-Z_][a-zA-Z0-9_]*

%%

\"|\'             { str2token(yyextra, yytext)->cti = STRING;                                }
struct            { adv(yytext, yyleng); token(yyextra, NULL, yyleng, Struct);               }
enum              { adv(yytext, yyleng); token(yyextra, NULL, yyleng, Enum);                 }
union             { adv(yytext, yyleng); token(yyextra, NULL, yyleng, Union);                }
table             { adv(yytext, yyleng); token(yyextra, NULL, yyleng, Table);                }
file_identifier   { adv(yytext, yyleng); token(yyextra, NULL, yyleng, FILEID);               }
file_extension    { adv(yytext, yyleng); token(yyextra, NULL, yyleng, FILEEXT);              }
namespace         { adv(yytext, yyleng); token(yyextra, NULL, yyleng, NAMESPACE);            } 
attribute         { adv(yytext, yyleng); token(yyextra, NULL, yyleng, ATTRIBUTE);            }
root_type         { adv(yytext, yyleng); token(yyextra, NULL, yyleng, ROOT);                 }
"///".*           { adv(yytext, yyleng); } // TODO keep as comment for next token
"//".*            { adv(yytext, yyleng); }
{FALSE}           { adv(yytext, yyleng); token(yyextra, yytext, yyleng, CONST)->cti = FALSE; }
{TRUE}            { adv(yytext, yyleng); token(yyextra, yytext, yyleng, CONST)->cti = TRUE;  }
{IDENTIFIER}      { adv(yytext, yyleng); token(yyextra, yytext, yyleng, ID);                 }
{FLOAT}           { adv(yytext, yyleng); token(yyextra, yytext, yyleng, CONST)->cti = FLOAT; }
0[xX][a-fA-F0-9]+ { adv(yytext, yyleng); token(yyextra, yytext, yyleng, CONST)->cti = HEX;   }
[-+]?[0-9]+       { adv(yytext, yyleng); token(yyextra, yytext, yyleng, CONST)->cti = DEC;   }
0[bB][01]+        { adv(yytext, yyleng); token(yyextra, yytext, yyleng, CONST)->cti = BIN;   }
[\t\v\f\r ]+      { adv(yytext, yyleng);                                                     }
\n                { adv(yytext, yyleng);                                                     }
.                 { adv(yytext, yyleng); token(yyextra, yytext, yyleng, CHAR);               }

%%

int fb2_syywrap(yyscan_t yyscanner) {

  return 1; // We're done

}

void fb2scan(ctx_t ctx, const char * schema, uint32_t size) {

  YY_BUFFER_STATE fbs;                                      // Flex buffer state.

  line = schema;

  fb2_syylex_init_extra(ctx, & ctx->scanner);

  fbs = fb2_syy_scan_bytes(schema, (int32_t) size, ctx->scanner);

  fb2_syy_switch_to_buffer(fbs, ctx->scanner);

  while(fb2_syylex(ctx->scanner) > 0) {
    // doit
  }

  fb2_syylex_destroy(ctx->scanner);

#ifdef YYDEBUG
  fb2_pyydebug = 0;
#endif

}

void dummy_yyunput(void) {                                  // To avoid we have a compiler warning/error because we don't use yyunput

  //(int c, char * yy_bp , yyscan_t yyscanner)
  yyscan_t yyscanner = 0;

  yyunput(input(yyscanner), NULL, yyscanner);

}

int32_t fb2_pyylex(token_t tr[1], ctx_t ctx) {                // Called by the parser to get a token or a character.

  token_t tok = NULL;
//  int32_t rv = ctx->error ? YYerror : YYEOF;                // Return value; prepare with EOF when not in error.
  int32_t rv = ctx->error ? 256 : 0;                // Return value; prepare with EOF when not in error.

  if (! ctx->error) {
    if (ctx->tokenum < ctx->Tokens.num) {
      tok = ctx->nexttoken;
      ctx->token4bison = tok;
      ctx->nexttoken = tok2next(ctx->nexttoken);
      ctx->tokenum++;
    }  

    if (tok) {                                              // Found a token to process.
      tr[0] = tok;
      rv = (tok->type == CHAR) ? tok->text[0] : tok->type;  // When a single char, we return the character, otherwise the token type.
//      if (tok->size) printf("TOKEN [%s]\n", tok->text);
    }
  }

  return rv;

}
